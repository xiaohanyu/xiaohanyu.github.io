<!DOCTYPE html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie ie6 lte7 lte8 lte9"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie ie7 lte7 lte8 lte9"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie ie8 lte8 lte9"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie ie9 lte9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
  <head>
    
    <script type="text/javascript">        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-49528621-1']);
        _gaq.push(['_trackPageview']);

        (function() {
          var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
          ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
          var s  = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
</script>
    

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Build Static Site with Nanoc (I) &bull; 行者无疆 始于足下</title>
    <meta name="keywords" value="nanoc, org-mode, static-site">
    <meta name="description" value="Undescribed website.">
    <meta name="copyright" value="Copyright © Xiao Hanyu 2014 - Powered by Ruby, Nanoc and Emacs Org-mode.">
    <meta name="author" value="Xiao Hanyu">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Place favicon.ico and apple-touch-icon(s) in the root directory -->

    <link rel="alternate" title="行者无疆 始于足下 Atom feed"  type="application/atom+xml" href="">

    <!-- Bootstrap -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.1.0/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom -->
    
    <link rel="stylesheet" type="text/css" href="/assets/css/all-cb8af8ac03a.min.css">
    

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.7.1/modernizr.min.js"></script> -->
  </head>
  <body>

    <!-- Static navbar -->
    <nav class="navbar navbar-inverse navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">
            行者无疆 始于足下
          </a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="/categories/index.html">Categories</a></li>
            <li><a href="/tags/index.html">Tags</a></li>
            <li><a href="/atom.xml">Subscribe</a></li>
            <li><a href="/about/index.html">About</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown"><i class="glyphicon glyphicon-search"></i></a>
              <ul class="dropdown-menu" style="padding:12px;">
                <form class="form-inline" target="_blank" method="get" action="http://google.com/search">
                  <input type="hidden" value="site:www.xiaohanyu.me" name="q">
                  <input type="text" class="form-control pull-left" placeholder="Search" name="q">
                </form>
              </ul>
            </li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <!-- content -->
    <div class="grey pt">
  <div class="container">
  <div class="panel panel-default">
  <div class="panel-heading">
    <h1 style="display: inline-block">Build Static Site With Nanoc (I)</h1>
  </div>
  <div class="panel-body">
    <div class="row">
  <article class="col-sm-9 post">
    <p>07年我开始学会上网，那时候写 blog 应该还是一件相当时髦的事情。而我个人，作为一枚外表木讷闷骚，内心感情丰富的三好有为青年，自然对 blog 保持着强烈的好奇心，从一路转载，到絮叨自嗨，四五年坚持下来，总算找到了一点 blog 的感觉。所谓“工欲善其行，必先利其器”，头上顶了“书写是为了更好的思考”这面响当当的思想大旗，手头自然也希望能升级下一直以来残破不勘凑合能用的写作工具。于是祭出几年前刚开始折腾 Linux 时的那份耐性，断续折腾一年有余，总算略有小成。本文（及后续文章）尝试记录下这个 blog&nbsp;的一些技术细节，希望对后来人有所启发。</p>
<h2>Why&nbsp;Static?</h2>
<p>最原始的 blog 应该就是纯静态的个人主页，后来 blog 开始火的时候，各种线上平台一统天下，而对于有点折腾能力的人来说， <a href="https://wordpress.org/">WordPress</a> 则一支独秀。现如今，在 GitHub 当道的年代，由 <a href="https://pages.github.com/">GitHub Pages</a> 及其工具链 <a href="http://jekyllrb.com/">Jekyll</a>/<a href="http://octopress.org/">Octopress</a> 所组成的生态系统，则在程序员的圈子里吸引了足够的眼球和人气，也宣告着所谓 <a href="http://staticsitegenerators.net/">static site generator</a>（本文简称为<span class="caps">SSG</span>）在某种程度上的回归。</p>
<p>So, why&nbsp;static?</p>
从技术上来讲，传统的 blog 就是一个简化的 <a href="http://en.wikipedia.org/wiki/Content_management_system"><span class="caps">CMS</span></a> 系统。相较于 <span class="caps">CMS</span> ， blog 更多的是个人开放给外界的一个展示窗口，并不需要太多的交互和额外的用户注册管理系统（如各种 bbs/forum/group 等），&nbsp;其主要技术特性是：
<ul>
<li>面向个人</li>
<li>页面排版较为简单</li>
<li>内容管理相对单一，基本上以 post&nbsp;为主</li>
<li>需求模块较少，基本上就是 Comments, Categories, Tags,&nbsp;Archives</li>
</ul>
<p>显然，动用各种 dynamic 语言和各种高大上的 <span class="caps">SQL</span> 数据库来实现这么几条简单的 blog 平台需求，有些牛刀杀鸡之嫌。在这方面， <span class="caps">SSG</span> 所遵循的 fast, lightweight, easy-deployment 是很有优势的。最简单的 blog 完全可以只是一个 post list 页面。但是纯静态的 blog 又太简陋了，因此需要通过一些 hack 的手段，在 static 的页面上加入一些 dynamic 的东西， 这个 hack 的手段，就是各种 <span class="caps">SSG</span> 中所谓的 compile&nbsp;步骤。</p>
compile 步骤是所有 <span class="caps">SSG</span> 的核心，它的设计好坏决定了一个 <span class="caps">SSG</span> 的品质。大体上讲， <span class="caps">SSG</span>&nbsp;的工作方式如下：
<ol>
<li><strong>格式转换：</strong> 扫描所有 post ， 进行初步 compile（这步 compile 主要作用是进行格式转换，比如 markdown/textile -&gt; html&nbsp;）。</li>
<li><strong>汇总metadata：</strong> 汇总所有 post 的 metadata （比如 tag/category 可以用来做反向映射，datetime 可以用来给 post 进行排序），这些 metadata 信息可以在 template&nbsp;渲染的时候访问。</li>
<li><strong>渲染模板：</strong> 根据相应的 layout 规则，将 compile 后的 content 以及已有的 metadata 信息渲染成相应的页面 （比如每篇 post 都需要有 navbar 和 footbar， 这可以设定一下基础的页面 layout，包含公用的页面元素，然后通过模板继承或组合的方式，将 post 的内容以及相应的 metadata 信息渲染到这个 layout 中合适的位置，这就形成了你最终看到的 static page&nbsp;）。</li>
</ol>
<p><span class="caps">SSG</span> 最终会生成一坨静态的 html/css/js 文件，只要将其上传托管起来，所谓的 static site 就算大功告成了。不需要配置数据库，也不需要装什么 php/python(wsgi)/WordPress ，怎么样，够简单吧？ 与static site 部署简单相对的就是本地写作环境搭建的复杂，多数情况下，你需要至少掌握一门编程语言的工具链，从头到尾搭建一套完整的写作环境；你需要自己设计前端，页面排版（layout）；你还需要找到自己钟意的 Editor 和自己喜欢的 <a href="http://en.wikipedia.org/wiki/Comparison_of_document_markup_languages">document markup language</a> 。选择意味着纠结，也意味着灵活。 <strong>没有了浏览器的牵绊，你可以在自己钟爱的 Editor&nbsp;里运指如飞，畅写欲言。</strong></p>
<p>不同的 <span class="caps">SSG</span> 有不同的设计侧重点，有的提供内建的 out-of-box 的主题（ <a href="http://octopress.org/">Octopress</a> 基本上千篇一律），有的只提供机制（ <a href="http://nanoc.ws/">Nanoc</a> ）;有的只支持一种模板语言（ <a href="http://ruhoh.com/">Ruhoh</a> 默认支持 <a href="http://mustache.github.io/">mustache</a> ），有的只提供机制（ <a href="http://nanoc.ws/">Nanoc</a> ）;有的只支持一种标记语言（多数默认支持 <a href="http://en.wikipedia.org/wiki/Markdown">Markdown</a> ），有的只提供机制（ <a href="http://nanoc.ws/">Nanoc</a>&nbsp;）;</p>
相较于广大人民群众，程序员群体对于 blog&nbsp;平台往往还有一些特别的需求：
<ul>
<li>没有代码高亮是不能忍的</li>
<li>能支持数学公式的话就很高大上</li>
<li>没有版本控制你叫我怎么活？</li>
<li>不能一键 deploy，自动 compile/refresh&nbsp;，还叫程序员吗？</li>
</ul>
<p><span class="caps">SSG</span> 的先天不足在于，传统 blog 平台所必须的一些模块，如 Comments, Search 等必须借助第三方的服务来实现。比如 Comments 可以用 <a href="https://disqus.com/">Disqus</a> ， 而 Search 可以用 google site&nbsp;search。</p>
<p>总得来说， <span class="caps">SSG</span> 的门槛还是比较高的。高效灵活的背后，是耐心和时间。这或许就是 hack&nbsp;的乐趣所在吧。</p>
<h2>Org-mode</h2>
<p>我选择 <span class="caps">SSG</span> 的第一个标准就是必须支持 <a href="http://orgmode.org/">org-mode</a>&nbsp;。</p>
<p>Why&nbsp;org-mode?</p>
<p>其实 <a href="http://en.wikipedia.org/wiki/Markdown">Markdown</a> 是相当好的文档标记语言，绝大多数 <span class="caps">SSG</span> 对 Markdown 都有良好的支持。多数线上服务如 GitHub 、 Stackoverflow 也是以 Markdown 为默认文档标记语言。 Markdown 的生态圈也相当繁荣， 有很多优秀的线上线下的 Editor<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>。不过 Markdown 的先天不足在于， 其设计初衷导致 Markdown 的标准过于简单，功能不够，而各方英雄为了一已之私，不得不提出各种 Markdown 扩展来满足自己的日常需求。这样看来， Markdown 生态圈一片繁荣百花争春的背后，实则是一片混乱，没有一个统一的标准，容易“厂商锁定”。所有的扩展 Markdown 语言之中， <a href="https://help.github.com/articles/github-flavored-markdown">GitHub Flavored Markdown</a> 和 <a href="http://johnmacfarlane.net/pandoc/README.html#pandocs-markdown">Pandoc&#8217;s markdown</a> 是比较不错的。特别是 Pandoc&#8217;s Markdown，功能完善、规范、强大，如果你不是我这样的 org-mode 死忠，那么我强烈推荐你用 Pandoc&#8217;s&nbsp;Markdown。</p>
<p>而我之所以离不开 org-mode ，其一在于我个人患有严重的 Emacs 依赖症，其二是 <a href="http://orgmode.org/worg/org-contrib/babel/">org-babel</a> ，一个你用上了就再也离不开的东西。 org-babel 让简单静态的文档变成了完整的 live 的 workflow ，关于这点，学术界甚至有一些专门的 <a href="http://orgmode.org/worg/org-papers.html">Papers</a> 论述。限于篇幅，不在这里展开讨论。 Emacs 配上 org-mode&nbsp;，更如香车搭上美女，快感连连，高潮不断也。</p>
但是很不幸，对 org-mode 的坚持让我被迫放弃了一大半的 <span class="caps">SSG</span> 。事实上，在我刚开始着手调研 <span class="caps">SSG</span> 的时候，没有一个 <span class="caps">SSG</span> 提供对 org-mode 的良好支持。 org-mode 本身有一个非常原始并且极其难用的 <a href="http://orgmode.org/manual/Publishing.html">org-publish</a> ，稍加配置也可以当成一个原始的 <span class="caps">SSG</span> 来用。还有一些 <a href="http://orgmode.org/worg/org-blog-wiki.html">Emacs packages</a> ，基于 org-publish， 可以用来生成 static site，但是大多数都非常难用。 <a href="http://renard.github.io/o-blog/">o-blog</a> 看上去很漂亮，但是我始终没有搞明白怎么用。后来又尝试了下 <a href="https://github.com/kelvinh/org-page">org-page</a> ，还提了几个 patch ，但终究也不是很满意。于是就只能自己操刀，开始写 <a href="https://github.com/xiaohanyu/org-site">org-site</a>&nbsp;。断续写了一个月，出来一个原型，但最终还是放弃：
<ul>
<li>Elisp 写起来并不是很happy，没有 namespace&nbsp;是一大硬伤。</li>
<li>Org-mode 的代码设计并没有为开放式的 <span class="caps">API</span> 做过考虑。理论上，我可以把 Emacs org-mode 当成一个文档格式转换器，将 org-mode 转换成 html/pdf ，但是由于 Emacs 的特殊性，很多 Elisp <span class="caps">API</span> 都是以 Emacs <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Buffers.html">buffer</a> 而不是 file 为操作对象，这就让我必须写很多的 wrapper 代码，然后通过类似于 <code>(with-temp-buffer (do-some-thing))</code>&nbsp;的手段来绕过这个限制。</li>
<li>org-publish <span class="caps">API</span>&nbsp;依赖很多全局变量，写起来很别扭，经常要去翻原代码才能搞明白某个变量的意思。</li>
<li>org-mode 7.x 和 8.x&nbsp;之间变动很大，代码兼容性维护任重道远。</li>
<li>org-mode 生成的 html 模块性太差，需要用各种 regexp 提取有用的 body/<a href="http://en.wikipedia.org/wiki/Table_of_contents"><span class="caps">TOC</span></a> 并过滤掉不需要的 header/footer&nbsp;，不美。</li>
<li>一个优秀的 <span class="caps">SSG</span> ，除了格式转换，还需要很多配套的模块，比如自动检测文件改动、自动编译、灵活的路由规则等，而这些用 Elisp&nbsp;实现起来都很麻烦。</li>
</ul>
<p>至此，自动动手丰衣足食的计划宣告破产，被迫寻找并尝试 hack 一些成型的 <span class="caps">SSG</span> ，来支持 org-mode 写作。我最终的选择是 <a href="http://nanoc.ws/">Nanoc</a>&nbsp;。</p>
<h2>Nanoc</h2>
<p><a href="http://nanoc.ws/">Nanoc</a> 是我用过的所有 <span class="caps">SSG</span> 中最为灵活，也是使用门槛最高的一个。 Nanoc 官方的入门 <a href="http://nanoc.ws/docs/tutorial/">Tutorial</a> 中明确说明，你必须 &quot;have a basic understanding of Ruby and command line&quot;， 才有可能玩得通 Nanoc 。在我个人看来， Nanoc 的设计基本上严格遵循了 Unix 中 &quot;Provide mechanism, not policy&quot; 的哲学。用软件工程的术语来说， Nanoc 提供的是 library ，而非一套成型的 <span class="caps">SSG</span> 软件。 Nanoc 既不限定你所用的文档标记语言 &#8212; 你可以用 Markdown/Textile/Org-mode ，也不指定相应的编译规则，更不提供默认的 out-of-box&nbsp;的主题样式。总之，一切要自己来，学习曲线颇为陡峭，但学成之后可以随心所欲。</p>
Nanoc 创造了自己的术语体系，每个概念相互独立又彼此联系。理解了这些术语也就理解了 nanoc&nbsp;的工作原理：
<ul>
<li>item: 是 nanoc 要处理的实体。一个 item 可以是 html/css/markdown&nbsp;等文本文件，也可以是图片，还可以是你自己凭空创造出来的虚拟文件。</li>
<li>rule: 决定 nanoc 处理 item 的步骤。 rule 分为两种， compilation rule 和 routing rule 。 其中 compilation rule 又分为 filter rule 和 layout rule 。 filter rule 一般用于文档格式转换，而 layout rule 则用于页面布局排版。 routing rule 决定 item 在 compile 之后在 output&nbsp;中的路径。</li>
<li>helper: 一些辅助代码，用于扩展 nanoc&nbsp;。</li>
<li>metadata: 元信息。 nanoc 对于每个 item 可附加的 metadata 没有任何限制。典型的 metadata 可以是 tag/category/datatime&nbsp;。</li>
<li>representation: 可以理解为输出格式。比如，同一个 item 可以同时 compile 为 html/pdf 两种格式。每种格式可以用自己独立的 rule&nbsp;。</li>
</ul>
<p>可以说， nanoc 为 <span class="caps">SSG</span> 的领域制定了一套相当棒的 standard 。事实上， 确实有人仿照着 nanoc 的 standard ，用 Haskell 重新实现了 nanoc ，这就是 <a href="http://jaspervdj.be/hakyll/">hakyll</a><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> 。我曾经短暂尝试过 hakyll ，但最终放弃，回到了 nanoc 的怀抱。而这基本上要归功于 Ruby&nbsp;。</p>
<h2>Ruby</h2>
<p>我并不是某一门编程语言的死忠。如果让我用一个字来形容 Ruby ，那就是“舒服”。是的， <a href="http://en.wikipedia.org/wiki/Yukihiro_Matsumoto">Matz</a> 没有骗你， Ruby 是写起来相当舒服的一门语言。 Ruby 的包管理机制 <a href="http://bundler.io/">bundler</a> + <a href="https://rubygems.org/">gem</a> 是我用过的所有包管理器中最先进最好用的， 比之于什么 Python 的 <a href="http://www.virtualenv.org/en/latest/">virtualenv</a> + <a href="http://www.pip-installer.org/en/latest/">pip</a> 之流要好用太多。至于 Haskell 的 <a href="http://www.haskell.org/cabal/">cabal</a> 基本上就是个奇葩的存在，连基本的 uninstall 功能都没有（是不是想起了 Python 的 <code>easy_install</code> ？），更不用提类似于 virtualenv/sandbox 这类先进功能了。不过这些都还可以忍受， Haskell 的 cabal 最蛋疼最奇葩的一点就是，好好的用着 <code>cabal install</code> ，说不定哪一天就会蹦出来各种莫名其妙的依赖问题， <a href="http://en.wikipedia.org/wiki/Dependency_hell">dependency hell</a> ， 唯一的解决办法就是 <code>rm -rf $HOME/.cabal</code> ， 然后重装然后祈祷……而 Haskell 又是一门编译型的静态语言，这就使得装 package&nbsp;的时间很长，令人不快。</p>
<p>语言层面， Ruby 中内置的 regexp （对比下 Python 的 <code>re.compile</code> ） 强大易用；其完整的对 lambda/block 的支持（对比下 Python 中阉割的 lambda ），能让每一个有点 Lisp 基础的人找到熟悉的感觉； Ruby 从 Unix Shell 以及 Perl 中借鉴而来的很多小聪明如 <a href="http://en.wikipedia.org/wiki/Here_document">here document</a>/<a href="http://en.wikipedia.org/wiki/String_interpolation">string interpolation</a>/command interpolation(Ruby backticks)， 使 Ruby 超越了 Python/Perl/Shell ，成为写 quick and dirty 的 Unix Script 的上上之选； Ruby 社区一些极富创造力的一些 package 如 <a href="http://rake.rubyforge.org/">rake</a>/<a href="https://github.com/guard/guard">guard</a> ，则让你的 hack&nbsp;之旅充满了快乐。</p>
<p>尽管 Ruby 这样那样好，但是 Haskell 社区有一枚神器，让人欲罢不能，这就是文档格式转换的瑞士军刀 &#8212; <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a>&nbsp;。</p>
<h2>Pandoc</h2>
<p>文档格式转换一直是一大难题，究其原因，是在于不同的文档格式有不同的表现能力和设计侧重点。比如原始的 Markdown 格式没有 table （表格）的支持，你怎么把 html 转换成 Markdown ? 反过来， html 中的 form 转换成其它格式，又该如何表现？ Microsoft Word 2003及之前版本的文档格式都是二进制且没有公开的文档格式标准， 想要完整的支持这种格式需要做大量的反向工程（ <a href="https://www.openoffice.org/">OpenOffice</a> 和 <a href="https://www.libreoffice.org/">LibreOffice</a>&nbsp;干的就是这事，可想这工作量）。</p>
<p>文档格式转换的软件千千万万，但是多数都只是 ad-hoc 的办法， pandoc 的创新之处在于发明了一种中间格式（ <a href="http://johnmacfarlane.net/pandoc/scripting.html">json-formatted <span class="caps">AST</span></a>&nbsp;），即先将原始文档格式先解析并转换成这种中间格式，然后经过系列处理转换成目标文档格式，从而提供了大一统的解决方案。</p>
<pre class="example"><code>                         source format
                              ↓
                           (pandoc)
                              ↓
                      JSON-formatted AST
                              ↓
                           (filter)
                              ↓
                      JSON-formatted AST
                              ↓
                           (pandoc)
                              ↓
                        target format
</code></pre>
<p>Pandoc 对于每种支持的输入格式，都提供了完整的 parser （ pandoc 中叫做 reader ），通过 parser 将输入文档转换成结构化 json 格式的 <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree"><span class="caps">AST</span></a> 。然后我们可以根据自己的需求，写一些脚本来操作 pandoc <span class="caps">AST</span> ，再转换成最终的输出目标格式（ Pandoc 中叫做 writer ）。Pandoc 把这个操作 <span class="caps">AST</span> 的程序脚本叫做 <a href="http://johnmacfarlane.net/pandoc/scripting.html#json-filters">filter</a> ，借助 filter ，理论上可以实现非常丰富的功能。至于调用 filter 的方法，最简单的是通过 Unix&nbsp;管道操作，比如：</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">pandoc</span> -f SOURCEFORMAT -t json <span class="kw">|</span> <span class="kw">runhaskell</span> filter.hs <span class="kw">|</span> <span class="kw">pandoc</span> -f json -t TARGETFORMAT</code></pre>
<p>Pandoc 的首选格式语言是 Markdown 。为了弥补 Markdown 的先天不足， pandoc 在原始 Markdown 的基础上增加了许多有用的扩展。通过这些扩展， <a href="http://johnmacfarlane.net/pandoc/README.html#pandocs-markdown">Pandoc&#8217;s markdown</a>&nbsp;自成一套完备、规范、通用、强大的文档标记语言。</p>
<p>Pandoc 在 <span class="caps">1.12.3.2</span> 版本之前是不支持 org-mode 作为输入格式的。这也让我头疼了许久。我最原始的想法是将 Emacs 当成一个 org-mode 的文档格式转换器，定制 emacs org-mode filter 集成到 nanoc&nbsp;：</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Nanoc</span>::<span class="dt">Filters</span>

  <span class="kw">class</span> <span class="dt">OrgModeHtml</span> &lt; <span class="dt">Nanoc</span>::<span class="dt">Filter</span>
    identifier <span class="st">:org_mode_html</span>
    type <span class="st">:text</span> =&gt; <span class="st">:text</span>

    require <span class="st">&#39;systemu&#39;</span>
    require <span class="st">&#39;tempfile&#39;</span>

    <span class="kw">def</span> run(content, params = {})
      <span class="co"># Run command</span>

      tmp_org_file = <span class="dt">Tempfile</span>.new(<span class="st">&#39;nanoc_tmp_org_file&#39;</span>, <span class="st">&#39;/tmp&#39;</span>)
      tmp_org_file &lt;&lt; content
      tmp_org_file.close(<span class="dv">nil</span>)

      elisp_code =<span class="ot"> %{</span>
<span class="st">(progn</span>
<span class="st">  (require &#39;org)</span>
<span class="st">  (find-file-read-only &quot;</span><span class="ot">#{</span>tmp_org_file.path<span class="ot">}</span><span class="st">&quot;)</span>
<span class="st">  (org-mode)</span>
<span class="st">  (if (version&lt; org-version &quot;8.0&quot;)</span>
<span class="st">      (progn</span>
<span class="st">        (setq org-export-html-postamble nil)</span>
<span class="st">        (org-export-as-html 3))</span>
<span class="st">    (progn</span>
<span class="st">      (setq org-html-postamble nil)</span>
<span class="st">      (org-html-export-as-html)))</span>
<span class="st">  (message &quot;%s&quot; (buffer-string)))</span>
<span class="ot">}</span>

      cmd = [<span class="st">&#39;emacs&#39;</span>, <span class="st">&#39;-Q&#39;</span>, <span class="st">&#39;--batch&#39;</span>,
             <span class="st">&#39;--eval&#39;</span>, elisp_code]

      stdout = <span class="st">&#39;&#39;</span>
      stderr = <span class="st">&#39;&#39;</span>
      status = systemu(cmd,
                       <span class="st">&#39;stdout&#39;</span> =&gt; stdout,
                       <span class="st">&#39;stderr&#39;</span> =&gt; stderr)

      <span class="co"># Show errors</span>
      <span class="kw">unless</span> status.success?
        <span class="dt">$stderr</span>.puts stderr
        raise <span class="st">&quot;Emacs org-mode filter failed with status </span><span class="ot">#{</span>status<span class="ot">}</span><span class="st">&quot;</span>
      <span class="kw">end</span>

      <span class="co"># Get result</span>
      body = <span class="ot">/&lt;body&gt;.*&lt;\/body&gt;/m</span>.match(stderr)
      body[<span class="dv">0</span>]
    <span class="kw">end</span>

  <span class="kw">end</span>

<span class="kw">end</span></code></pre>
<p>这段代码的大体思路是将 emacs 当成 elisp 的解释器，喂给其一段 elisp 代码，调用 org-mode 的 export 功能 （ org-mode 7.x 版本中调用 <code>(org-export-as-html)</code> ， 8.x 版本中调用 <code>(org-html-export-as-html)</code> ），然后再通过 regexp 正则匹配的方式提取出 html 中的 body 部分作为 nanoc filter&nbsp;的返回值。显而易见，这段代码冗长，乏味，别扭，不美。</p>
<p>好在我生逢其时，英雄出世， <a href="http://zeitlens.com/">Albert Krewinkel</a> 大手笔横空祭出几个 patch ，给 pandoc 提供了一个完备的 org-reader ，把我感动得一塌糊涂，我还特别写了封邮件感谢人家。一番 <code>cabal install</code> 之后， pandoc 总算能支持 org-mode&nbsp;作为其输入格式了，很完美。</p>
<p>最后要解决的问题就是 pandoc 和 nanoc 的集成。 nanoc 本身有一个内建的 <code>Nanoc::Filters::Pandoc</code> ，调用的是 <a href="https://github.com/alphabetum/pandoc-ruby">PandocRuby</a> 。但是 nanoc 本身的 <span class="caps">API</span> 和 PandocRuby <span class="caps">API</span> 并不是很匹配，无法传递一些参数来启用 pandoc 的某些高级特性 （参考 <a href="http://stackoverflow.com/questions/14646741/nanoc-how-can-i-pass-options-to-pandoc-ruby">stackoverflow</a> ）。万般无奈之下，只能自己动手，重写一个 nanoc pandoc filter，完整代码参考 <a href="https://gist.github.com/xiaohanyu/9866531">github gist</a>&nbsp;。</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Nanoc</span>::<span class="dt">Filters</span>

  <span class="kw">class</span> <span class="dt">PandocHtml</span> &lt; <span class="dt">Nanoc</span>::<span class="dt">Filter</span>
    identifier <span class="st">:pandoc_html</span>
    type <span class="st">:text</span> =&gt; <span class="st">:text</span>

    <span class="kw">def</span> run(content, params = {})
      input_format = <span class="kw">case</span> item[<span class="st">:extension</span>]
                     <span class="kw">when</span> <span class="st">&#39;org&#39;</span>
                       <span class="st">&#39;org&#39;</span>
                     <span class="kw">when</span> <span class="st">&#39;md&#39;</span>, <span class="st">&#39;markdown&#39;</span>
                       <span class="st">&#39;markdown&#39;</span>
                     <span class="kw">end</span>

      <span class="st">`pandoc --mathjax -f </span><span class="ot">#{</span>input_format<span class="ot">}</span><span class="st"> -t html5 &lt; </span><span class="ot">#{</span>item.raw_filename<span class="ot">}</span><span class="st">`</span>
    <span class="kw">end</span>

  <span class="kw">end</span>

<span class="kw">end</span></code></pre>
<p>代码思路很简单，就是通过 Ruby backticks 直接调用 pandoc ，然后将 pandoc 命令的 stdout 作为 nanoc filter 的返回值。通过进一步配置， nanoc 可以调用 pandoc 同时生成 html 和 pdf ，这样一来，同样的文章，即可以线上浏览，也可以打印下载，得益于 pandoc 的优秀设计， html 和 pdf&nbsp;版本的文章具有一致出色的排版效果。</p>
<p>至此，核心的技术问题已经基本解决，剩下的就是前端设计了，这是我的弱项，为了能让这个 blog 有一个“不那么难看”的样式，我特别花时间学习系统地学习了下 <span class="caps">HTML5</span> 和&nbsp;<span class="caps">CSS3</span>。这部分内容冗长乏味，非核心所在，下篇再表。</p>
<h2>Reference</h2>
<ul>
<li>&lt;<a href="http://freemind.pluskid.org/technology/the-unbearable-madness-of-static-blog-generators/">The Unbearable Madness of Static Blog Generators</a>&gt;， pluskid 的 blog ，重点介绍了 ruhoh&nbsp;。</li>
<li>&lt;<a href="http://clarkdave.net/2012/02/building-a-static-blog-with-nanoc/">Building a static blog with nanoc</a>&gt;， nanoc 入门教程，简洁明了&nbsp;。</li>
<li>nanoc powered&nbsp;的网站包括：
<ul>
<li><a href="https://developer.github.com/">GitHub Developer&nbsp;Site</a></li>
<li><a href="http://guides.spreecommerce.com/api/">Spree Commerce <span class="caps">API</span>&nbsp;site</a></li>
</ul></li>
<li><span class="caps">SSG</span> 名录大全： <a href="http://staticsitegenerators.net/">http://staticsitegenerators.net/</a></li>
<li>&lt;<a href="http://kelvinh.github.io/blog/2012/11/27/growth-process-of-org-page/">Org-page的成长史</a>&gt;，介绍了基于 org-mode 的 <span class="caps">SSG</span>&nbsp;。</li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>线上 Editor ： <a href="http://dillinger.io/">Dillinger</a>/<a href="https://stackedit.io/">StackEdit</a> ；线下 Editor ： <a href="http://mouapp.com/">Mou</a> 。<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>这其中有个八卦， hakyll 的作者 <a href="http://jaspervdj.be/">Jasper</a> 和 nanoc 的作者 <a href="http://stoneship.org/">Denis Defreyne</a> 在生活中是好朋友。而在某一年的 April fools&#8217; day， Denis 写了篇 &lt;<a href="http://nanoc.ws/the-road-to-nanoc-4-0/">The road to nanoc <span class="caps">4.0</span></a>&gt; ， 大意是要用 haskell 重写 nanoc 。<a href="#fnref2">↩</a></p></li>
</ol>
</section>


    <hr>

    <ul class="pager">
      <li class="previous"><a class="previous" title="New Blog, New Start" href="/2014/04/16/new-blog-new-start/">&larr; Prev</a></li>
      
      <li>
        <a id="show-disqus-comments" onclick='toggle_disqus()'>Show Disqus Comments</a>
      </li>
      
      <li class="next"><a class="next" title="Build Static Site with Nanoc (II)" href="/2014/07/25/build-static-site-with-nanoc-2/">Next &rarr;</a></li>
    </ul>

    
    <div id="disqus_thread"></div>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    <script type="text/javascript">
     function toggle_disqus (event) {
       $.ajaxSetup({cache:true});
       $.getScript("http://xiaohanyu.disqus.com/embed.js");
       $.ajaxSetup({cache:false});
       setTimeout(function () {
         $("#show-disqus-comments").fadeOut(3000);
       }, 1000);
     }
    </script>
    

  </article>

  <aside class="col-sm-3">
    <h4>Published</h4>
    <date>2014-05-05</date>

    <h4>Categories</h4>
    <ul class="tag-box">
      
      <li><a href=/categories/index.html#technology>Technology<span>2</span></a></li>
      
    </ul>

    <h4>Tags</h4>
    <ul class="tag-box">
      
      <li><a href=/tags/index.html#nanoc>Nanoc<span>2</span></a></li>
      
      <li><a href=/tags/index.html#ruby>Ruby<span>1</span></a></li>
      
      <li><a href=/tags/index.html#pandoc>Pandoc<span>1</span></a></li>
      
      <li><a href=/tags/index.html#emacs>Emacs<span>1</span></a></li>
      
    </ul>
  </aside>
</div>

  </div>
</div>

</div>

</div>

    <a href="#" class="btn back-to-top btn-dark btn-fixed-bottom"> <span class="glyphicon glyphicon-chevron-up"></span> </a>

    <footer id="footer">
      <div class="container">
        <div class="row centered">
            <p>
              Xiao Hanyu 2014 -
              Powered by <a href="http://nanoc.ws/">Nanoc</a>, <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a> -
              Licensed under
              <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
            </p>
      </div>
    </footer>

    <!--[if lt IE 8]>
    <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]-->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript"
            src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
    <script src="/assets/js/all-cb120e2b7c8.min.js"></script>
    
  </body>
</html>
